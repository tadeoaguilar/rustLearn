# Exercise Template

Use this template to create exercises for any module.

## Module Title: [Module Name]

**Phase**: [Phase Number and Name]
**Difficulty Level**: Beginner | Intermediate | Advanced | Expert
**Estimated Time**: [Total hours for all exercises]

**Prerequisites**:
- List required prior knowledge
- Completed modules

**Setup** (if needed):
```toml
[dependencies]
# Add any required dependencies
```

---

## Exercise 1: [Exercise Name]

**Difficulty**: Easy | Medium | Hard
**Time**: [X minutes]
**Learning Objectives**:
- What students will learn
- Key concepts covered

**Background** (optional):
Brief explanation of concepts needed.

**Task**:
Clear description of what to build/solve.

**Code Template** (if applicable):
```rust
// Starter code with TODOs
fn main() {
    // TODO: Implement solution
}
```

**Expected Output**:
```
What the program should output
```

**Tests** (if applicable):
```rust
#[test]
fn test_name() {
    assert_eq!(function_call(), expected_result);
}
```

**Hints**:
- Hint 1
- Hint 2
- Link to relevant docs

**Solution Approach** (optional):
High-level steps without giving away code.

---

## Exercise 2: [Exercise Name]

**Difficulty**: Easy | Medium | Hard
**Time**: [X minutes]

[Follow same structure as Exercise 1]

---

## Exercise 3-6: [More Exercises]

[Continue pattern with increasing difficulty]

---

## Bonus Challenge: [Advanced Exercise]

**Difficulty**: Very Hard
**Time**: 60-90+ minutes

[Complex real-world problem that combines all module concepts]

---

## Mini-Project: [Project Name]

**Time**: [2-4 hours]
**Description**: Build a complete application using module concepts

**Requirements**:
1. Requirement 1
2. Requirement 2
3. Requirement 3

**Features to Implement**:
- [ ] Feature 1
- [ ] Feature 2
- [ ] Feature 3

**Testing Checklist**:
- [ ] Unit tests for core logic
- [ ] Integration tests
- [ ] Edge cases handled

**Extension Ideas**:
- How to make it better
- Additional features

---

## Check Your Understanding

Before moving to the next module, ensure you can:

- [ ] Learning objective 1
- [ ] Learning objective 2
- [ ] Learning objective 3
- [ ] Completed minimum X exercises
- [ ] Built mini-project

---

## Common Mistakes to Avoid

1. **Mistake 1**: Description and how to avoid
2. **Mistake 2**: Description and how to avoid
3. **Mistake 3**: Description and how to avoid

---

## Debugging Tips

- How to debug common errors
- Tools to use
- Where to look for help

---

## Performance Considerations (if relevant)

- Optimization tips
- Benchmarking approaches
- Trade-offs to consider

---

## Real-World Applications

- How these concepts are used in production
- Example libraries/projects using these techniques
- Career relevance

---

## Additional Resources

- [Resource 1](link) - Description
- [Resource 2](link) - Description
- Official documentation links
- Video tutorials
- Blog posts
- Example projects on GitHub

---

## Next Steps

- What module to tackle next
- How concepts build on each other
- Suggested projects to reinforce learning

---

## Exercise Difficulty Guidelines

### Easy (10-20 min)
- Single concept focus
- Clear instructions
- Minimal problem-solving required
- Template code provided

### Medium (25-45 min)
- Combines 2-3 concepts
- Requires some design decisions
- Some template code
- Moderate problem-solving

### Hard (60+ min)
- Combines many concepts
- Significant design required
- Minimal templates
- Complex problem-solving

### Bonus/Challenge (90+ min)
- Real-world complexity
- Multiple components
- Research required
- Production-quality expected

---

## Tips for Exercise Creators

1. **Start Simple**: First exercise should be very basic
2. **Build Progressively**: Each exercise slightly harder
3. **Provide Context**: Explain why concepts matter
4. **Include Tests**: Help students verify correctness
5. **Real Examples**: Use realistic scenarios
6. **Multiple Approaches**: Show different solutions
7. **Common Errors**: Anticipate and address mistakes
8. **Encourage Exploration**: Bonus challenges for depth

---

## Sample Exercise Progression

For a module on "Testing":

1. **Exercise 1** (Easy): Write a simple unit test
2. **Exercise 2** (Easy): Test error cases
3. **Exercise 3** (Medium): Integration test
4. **Exercise 4** (Medium): Mock dependencies
5. **Exercise 5** (Hard): Test async code
6. **Exercise 6** (Hard): Property-based testing
7. **Bonus**: Full test suite for a library
8. **Project**: TDD implementation of calculator

---

## Copy This Template

To create exercises for a new module:

1. Copy this template to the module folder
2. Rename to `exercises.md`
3. Fill in module-specific content
4. Follow difficulty progression
5. Include 6-8 regular exercises
6. Add 1-2 bonus challenges
7. Include a mini-project
8. Test the exercises yourself
9. Add solutions in separate file (optional)

---

## Questions to Ask When Designing Exercises

- What are the 3-5 core concepts to teach?
- How do these concepts build on previous modules?
- What real-world problems does this solve?
- What mistakes do beginners typically make?
- How can I make this engaging and practical?
- What tools/crates are commonly used?
- How can I assess understanding?
